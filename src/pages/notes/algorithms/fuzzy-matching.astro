---
import NotesLayout from "../../../layouts/NotesLayout.astro";
---

<NotesLayout title="Fuzzy Matching">
  <h1 class="roboto-bold title">Fuzzy Matching</h1>
  <p class="roboto-light">
    Awhile back at work, my senior dev approached me and mentioned that a client
    of ours was facing some issues. In a nutshell, they sell tickets to events
    and when the patron arrives at the event. Instead of scanning a ticket,
    patrons scan their ID which acts as both ID validation and ticket
    validation. This simplifies the process… but introduced a new problem:
    patrons sometimes entered details that didn’t exactly match their IDs
    (nicknames, typos, even intentional variations). Consider some examples:
  </p>
  <ul class="roboto-light">
    <li class="roboto-light">Johnathan vs. John (Nicknames)</li>
    <li class="roboto-light">
      2000-01-01 vs. 2001-01-11 (Intentionally entering differing birthdays due
      to privacy concerns)
    </li>
  </ul>
  <p class="roboto-light">
    These are obviously the tip of the iceberg in the grand scheme of things.
    But long story short, we needed a way to account for discrepancies to ensure
    smooth check-in processes
  </p>
  <h2 class="roboto-bold-italic">Enter, "fuzzy matching"</h2>
  <p class="roboto-light">
    Fuzzy matching is a technique used to find strings that are roughly similar.
    It is particularly useful in scenarios where exact matches are not feasible
    due to typos, variations in spelling, or different formats. The goal is to
    identify records that are likely to refer to the same entity, even if they
    are not identical.
  </p>
  <h2 id="problem" class="roboto-bold-italic">The "Problem Space"</h2>
  <p class="roboto-light">
    Some examples of string matching issues were mentioned above. But to put
    into perspective, fuzzy matching (I recently learned) is widely used in
    areas outside of just ID verification. For example:
  </p>
  <ul class="roboto-light">
    <li>Data Cleaning & Record Linking</li>
    <li>E-commerce / Retail</li>
    <li>Fraud & Finance</li>
    <li>Entertainment / Media</li>
    <li>Search Engines & NLP</li>
    <li>Science & Research</li>
    <li>Everyday Business Apps</li>
  </ul>
  <p class="roboto-light">
    Despite all of these though, the goal in our scenario remains the same: to
    accurately match and link Personal Identifiable Information (PII), even when
    faced with discrepancies such as typos, ocr errors, nickname or other
    variations.
  </p>
  <p class="roboto-light">
    Fortunately, there are a couple of libraries already in this space such as <a
      href="https://pypi.org/project/fuzzywuzzy/">FuzzyWuzzy</a
    > and <a href="https://github.com/rapidfuzz/RapidFuzz">RapidFuzz.</a> There's
    a few issues with these however for our exact application.
  </p>
  <p class="roboto-light">
    In designing a fuzzy matcher, I had to account for a few key factors that
    off-the-shelf libraries either didn’t handle or didn’t handle well for our
    scenario:
  </p>
  <ul class="roboto-light">
    <li>
      <b>Weights matter:</b> Not all fields are equal. First names are flexible (nicknames,
      short forms) while dates of birth and addresses are more consistent.
    </li>
    <li>
      <b>Custom scoring:</b> Some fields may be more prone to error, which entails
      allowable distances and number of edits. For example, first names allow more
      flexibility while last names follow stricter rules.
    </li>
    <li>
      <b>OCR / domain-specific corrections:</b> Some libraries only handle pure string
      edits. We can explicitly account for common OCR misreads (like '1' vs 'i')
      and multi-character substitutions.
    </li>
    <li>
      <b>Structured multi-field matching:</b> Libraries often treat inputs as single
      strings. Our approach can consider multiple fields simultaneously (first name,
      last name, DOB, etc.) and calculate a combined score.
    </li>
    <li>
      <b>Extensibility:</b> Difficult to add new rules or heuristics, like nicknames,
      expiry of records, parallel field searches, or next-character prediction, without
      being constrained by library APIs.
    </li>
  </ul>
  <p class="roboto-light">
    Originally, before my senior dev approached me, the CEO suggested tackling
    OCR errors. This sparked the idea for a trie-based fuzzy matcher. Rather
    than diving too deep into trie mechanics, the concept was straightforward:
    traverse a trie with a known string (e.g., "J0hn"), and at characters that
    might be OCR errors, explore possible corrections such as swapping '0' for
    'o'.
  </p>
  <p class="roboto-light">
    During a hackathon, I implemented my trie-based matcher and ran it across
    our database. It identified roughly 40,000 duplicate entries out of 1
    million records — outperforming libraries like FuzzyWuzzy and RapidFuzz for
    the use-case. While the initial focus was OCR correction, the hackathon
    fueled the basis of using a trie for fuzzy matching as well.
  </p>
  <h2 id="implementation" class="roboto-bold-italic">
    Implementing fuzzy matching
  </h2>
  <p class="roboto-light">
    The first thing we need to do is create a trie. Tries are a tree-like data
    structure that efficiently store and retrieve strings by their prefixes. The
    key to a trie is it's node:
  </p>
  <ul>
    <li>A trie node represent a single character</li>
    <li>A trie node contains a map of it's children (the next characters)</li>
    <li>A trie node indicates if it's the end of a string</li>
    <li>A tries root node is empty, and only contains children nodes</li>
  </ul>
  <p>To get a better idea of the structure:</p>
  <div class="code">
    <ul class="tabs">
      <li class="active">Go</li>
    </ul>
    <div class="code-content">
      <pre
        class="active"
        is:raw>

  type TrieNode struct {
    Char rune
    Children map[rune]*TrieNode
    IsEndOfString bool
  }
      </pre>
    </div>
  </div>
  <p>
    Consider now we have the following word to insert into our trie: "John".
    Going step by step:
  </p>
  <ul>
    <li>1. Start at the root node and grab it's map of children</li>
    <img src="../../../../public/fuzzy-matching/root.png" />
    <li>2. Using 'J', check if the current node contains 'J' in it's map</li>
    <img src="../../../../public/fuzzy-matching/root_with_children_map.png" />
    <li>
      3. If it does, move to the child node corresponding to 'J', otherwise
      create it (in this case, we create it) and assign the value 'J'
    </li>
    <img src="../../../../public/fuzzy-matching/root_with_j.png" />
    <li>4. Move to the node containing 'J'</li>
    <img src="../../../../public/fuzzy-matching/current_j.png" />
    <li>
      5. Repeat steps 2-4 for the remaining characters ('o', 'h', 'n') and mark
      the end of the string at the last node
    </li>
    <img src="../../../../public/fuzzy-matching/current_n.png" />
  </ul>
  <p>
    Now if we follow this process for "Jane", "Jacob" and "Jill", we'd have a
    structure that looks a little like this:
  </p>
  <img src="../../../../public/fuzzy-matching/trie.png" />
</NotesLayout>
