---
import NotesLayout from "../../../layouts/NotesLayout.astro";

---
<NotesLayout>
  <h1 class="roboto-bold">Linear Regression</h1>
<p class="roboto-light">
  I've recently begun exploring machine learning finding it rather exciting.
  Outside of common applications like chat-bots and LLM's like Chat-GPT, AI and
  machine learning is being used in fields such as biology, finance, healthcare
  and social media. Machine learning in simple terms is
  <span class="bold italic"
    >"Programming a computer to make predictions based off data"</span
  >. For example, say you're given data that contains the size of a city in
  km<sup>2</sup>
  and its population.
</p>
<img
  src="https://res.cloudinary.com/dusakygel/image/upload/v1734927444/Screenshot_2024-12-22_194531_y0wlcs.png"
  alt="A chart containing the population of different cities in the left column and their area in the right column"
/>
<p class="roboto-light">
  We could take this information, and use it to predict how large a city might
  be based off of its population. The population in this scenario is the input
  (x) and the area is the output (y). This is in essence our
  <span class="italic">training data</span> that we will use to train our model.
  If you reflect back to high-school, you may remember algebra class and more
  specifically this fomula:
</p>
<ul class="roboto-light">
  <li>y = mx + b</li>
</ul>
<p class="roboto-light">
  This formula allows you to calculate the y value based off of a given x value
  if you have the slope and the y-intercept. I'll explain this in a little bit
  more detail down the line but this formula is very similar to what's used in
  linear regression. The biggest difference though is that in machine learning,
  you're calculating the <span class="bold italic">predicted</span> value and
  not the actual value. The formula for machine learning is:
</p>
<ul class="roboto-light">
  <li>f<sub>w,b</sub><sup>(x)</sup> = wx + b</li>
</ul>
<p class="roboto-light">
  Once you take a look at the graph below, the reason we're calculating the
  predicted value and not the actual value becomes a little more clear. The data
  points aren't going to fall directly on a <span class="italic">line</span> if
  we drew one on the graph. Instead, the majority of the data-points are going
  to be in the general vicinity of the line that we draw.
</p>
<img
  src="https://res.cloudinary.com/dusakygel/image/upload/v1734927660/Screenshot_2024-12-22_212045_li3u2i.png"
  alt="A graph of data points with the population in millions on the x-axis and it's area in kilometers squared on the y-axis"
/>
<p class="roboto-light">
  This is really important because it goes back to my initial statement of how
  machine learning makes predictions. Furthermore, the machine learning model is
  only as good as the data that we use. You could run into issues where the data
  is biased, lack of data, or the data is "noisy" meaning that simply put, it's
  all over the graph.
</p>
<h2 class="roboto-bold">The formula</h2>
<p class="roboto-light">
  f<sub>w, b</sub><sup>(x)</sup> = wx + b is the formula that we use for making
  predictions with our data or in other words,
  <span class="italic bold">our model.</span>
  The machine learning formula is similar to algebra's y = mx + b, however there
  are some slight differences between the terminology that we use. In algebra's
  y = mx + b:
</p>
<ul class="roboto-light">
  <li>y: The actual output value</li>
  <li>m: The slope (rate of change)</li>
  <li>b: The y-intercept</li>
  <li>x: The input value</li>
</ul>
<p class="roboto-light">
  Where as in machine learning's f<sub>w, b</sub><sup>(x)</sup> = wx + b:
</p>
<ul class="roboto-light">
  <li>f<sub>w, b</sub><sup>(x)</sup>: The predicted output value</li>
  <li>w: The weight (determines the steepness of the line)</li>
  <li>b: The bias (adjusts the line up or down)</li>
  <li>x: The input feature (e.g., population)</li>
</ul>
<img
  src="https://res.cloudinary.com/dusakygel/image/upload/v1734927444/Screenshot_2024-12-22_202459_jrovme.png"
  alt="A graph depicting a line with the y-intercept (bias) circled at zero and a triangle illustrating the slope (rise over run) of the line."
/>
<p class="roboto-light">
  In the above graph, the bias is 0. However if the line were to intercept the
  y-axis at say 500 or 1000, then that would be our bias (b). As for the slope
  or weight, we could calculate it temporarily by eye-balling it and using
  <a href="https://www.cuemath.com/algebra/rise-over-run/">rise over run:</a>
  (y<sup>2</sup> - y<sup>1</sup>) / (x<sup>2</sup> - x<sup>1</sup>). Taking a
  look at the graph
</p>
<img
  src="https://res.cloudinary.com/dusakygel/image/upload/v1734929363/Screenshot_2024-12-22_214916_mwzbud.png"
  alt="An image with a line drawn from x one million to the sloping line, than to roughly y 700, and another from x two millions to roughly y 1250 to calculate rise over run"
/>
<p class="roboto-light">
  and using our nifty little rise over run formula, we could calculate the
  weight:
</p>
<ul class="roboto-light">
  <li>y2: 1200</li>
  <li>y1: 600</li>
  <li>x2: 2 000 000</li>
  <li>x1: 1 000 000</li>
  <li>w: (1200 - 600) / (2 000 000 - 1 000 000)</li>
  <li>Calculated: 0.0006</li>
</ul>
<h2>Making Predictions</h2>
<p class="roboto-light">
  Using our bias and calculated weight, we could now use our formula f<sub
    >w, b</sub
  ><sup>(x)</sup> = wx + b to predict how large a city might be if it had a
  population of 3 000 000.
</p>
<ul class="roboto-light">
  <li>w: 0.0006</li>
  <li>b: 0</li>
  <li>x: 3 000 000</li>
  <li>f<sub>w, b</sub><sup>(x)</sup>: (0.0006 * 3 000 000) + 0</li>
  <li>Calculated: 1 800</li>
</ul>
<p class="roboto-light">
  A city with a population of 3 000 000 would have a predicted value of 1 800.
  <span class="bold italic"
    >"But wait a minute Gavin, 6m<sup>2</sup> per person doesn't seem very
    accurate."</span
  >
  and you're absolutely right. The issue with our current model is that it
  doesn't minimize the <span class="bold italic">cost</span>. In other words,
  our w and b values are off and as a result, our model isn't as accurate as
  possible to the data. The values have just been arbitrarily chosen rather than
  mathematically and in order to minimize our cost, we need to use gradient
  descent and cost functions but those are entire posts of their own. For
  example though, another potentially accurate model may be represented by this
  graph instead.
</p>
<img
  src="https://res.cloudinary.com/dusakygel/image/upload/v1734931119/Screenshot_2024-12-22_221436_lxoojt.png"
  alt="A graph of data points with the population in millions on the x-axis and it's area in kilometers squared on the y-axis"
/>
<p class="roboto-light">
  For this talk, there isn't exactly a whole lot of code to show as it's just a
  formula, however I would recommend checking out this interactive exercise that
  google has
  <a
    href="https://developers.google.com/machine-learning/crash-course/linear-regression/parameters-exercise"
    >here</a
  >
  which better shows how you can alter the bias (b) and weight (w) parameters.
  Furthermore it also shows loss (cost) which you can try to minimize by
  manipulating your weight (w) and bias (b).
</p>
<p class="roboto-light">
  If you do however want to try other values for x, here's a small code snippet.
</p>
<div class="code">
  <ul class="tabs">
    <li class="active">Python</li>
  </ul>
  <div class="code-content">
    <pre class="active">
      
    # Example of calculating fw,b(x) = wx + b
    w = 0.0006
    b = 0
    x = 3_000_000
    f_x = (w * x) + b
    </pre>
  </div>
</div>
</NotesLayout>